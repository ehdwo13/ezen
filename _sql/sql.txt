Day 01
root => 최상위 유저
     => 하위 유저생성가능 (root가 지정한 db만 사용권한을 얻음)

productName(카멜표기법) - JAVA
product_name(스네이크표기법) -DB

--환경 변수 설정--
path

cmd창에서 명령어 입력
//접속
mysql -uroot -pezen
//종료
exit
//database 확인명령어
show databases;
//삭제
DROP DATABASE test;
//생성
create database test;
//데이터베이스를 사용
use test;

//user 생성
use mysql;
//user 확인
select * from user;
//user 생성구문
create user '이름'@'localhost' identified by '비번';
create user 'mysqluser'@'localhost' identified by 'mysql';

//user 권한부여
grant all privileges on solo_test.* to 'mysqluser'@'localhost' with grant option;

//권한적용
flush privileges;

-----------------------------------------------------------------------------------
//user 변경해서 접속
mysql -u mysqluser -p mysql
//database 사용
use test;

-----------------------------------------------------------------------------------
mysql 데이터 자료형
숫자
(정수) 
-BIT(m) : 1~64 binary 데이터 값을 저장
-BOOL : true(1), false(0) == TINYINT(1)
-TINYINT(m) : 0~255 사이의 작은수를 표현 (-128~127)
-SMALLINT(m) : 2BYTE
-MEDIUMINT(m) : 3BYTE 
-INT(m) : 4BYTE => java의 int와 동일
-BIGINT(m) : 8BYTE => java의 long과 동일
(실수)
----MYSQL 8.0.17 버전이후부터 사용되지 않음----
-FLOAT(m,d) : 정밀도가 작은 부동소수점 표현(d:소수자리수)
-DOUBLE(m,d) : 정밀도가 큰 부동소수점 표현
----사용중----
-DECIMAL(m,d) : 고정소수점 표현 (d.소수자리수)
문자
-CHAR(m) : 고정길이 문자열(0~255)
-VARCHAR(m) : 가변길이 문자열(0~65536)
-TINYTEXT : 1BYTE 문자열 저장 => 가변길이
-TINYBLOB : 바이너리 데이터 저장용 (그림,동영상 미디어)
-TEXT : 2BTYE 가변길이 문자열
-MEDIUMTEXT : 3BYTE
-LONGTEXT : 4BYTE
날짜
-DATE : 날짜표현
-DATETIME : 날짜시간 => 가장 많이 씀
-TIMESTAMP : Insert, update 연산에 유리한 형태
-YEAR : 연도만
-TIME : 시간만

제약조건
PK : Primary key => 기본키 속성 추가
NN : not null => 데이터 값으로 null 허용하지 않음
AI : auto increment => 자동증가 : 정수만 가능
UQ : unique => 중복안됨
B : 바이너리값
UN : unsigned => 음수 안됨
ZF : zero fill => 숫자 앞에 0으로 채우기 ex)0001
G : generated => 속성자동생성

주석처리
-- 주석처리
/* 주석처리 */

-----------------------------------------------------------------------------------
테이블 생성
test1
create table 테이블명(
필드명 속성1 속성2,
필드명 속성1 속성,
...
primary key(필드명));

id AI, name, age, address

create table test1(
id int auto_increment,
name varchar(20) not null,
age int default 20,
address varchar(50),
primary key(id));
-----------------------------------------------------------------------------------
테이블 구조 확인
desc test1;
전체 데이터 확인
select * from test1;
-----------------------------------------------------------------------------------
데이터 추가 구문
insert into 테이블명(필드명) values(데이터)
insert into test1(name, address)
values('홍길동','서울시');



홍길동 데이터만 검색
select * from test1 where name='홍길동';
select * from test1 where address='인천시';

-----------------------------------------------------------------------------------
DML : 조작어
insert (삽입)
select (조회)
update (수정)
delete (삭제)

DDL : 정의어
create (생성)
drop (삭제)
alter (변경)
-----------------------------------------------------------------------------------
테이블명 변경
RENAME table 테이블명(전) to 테이블명(후);
alter table attend rename column at_std_num to at_st_num;
-----------------------------------------------------------------------------------
테이블의 구조변경
alter table 테이블명 add 필드명
속성1 속성2;

add (추가)
alter table test1 add tel varchar(10);

modify (수정)
alter table test1 modify tel varchar(10) default '1111';

CHANGE (수정 : 필드명도 수정가능)
alter table test1 change tel phone varchar(10) default '1111';

drop (제거)
alter table test1 drop phone;

위치설정
alter table test1 add tel varchar(10) after age;
-----------------------------------------------------------------------------------
update 테이블명 set 변경필드 = 변경값 where 조건
update test1 set phone = '5555' where id=5;
-----------------------------------------------------------------------------------
테이블 생성
테이블명 : test2
속성
- 학번(num)(숫자) 111,222,333
- 이름(name)(문자)
- 학과(dep)(문자)
- 주소(addr)(문자)
- 전화번호(tel)(문자)
create table test2(
num int auto_increment,
name varchar(20),
dep varchar(10),
address varchar(50),
tel varchar(20),
primary key(num));

-- 10명의 필드 추가
insert 구문 데이터 한번에 넣기
insert into test2 values
('김순이','영문학과','인천시','010-1314-3718' ),
( ),
( );

insert into emp values
(1001,'홍길동',3000,'기획부'),
(1002,'김유신',4000,'기획부'),
(1003,'이순신',2500,'총무부'),
(1004,'박문수',3000,'총무부');

1. age int로 추가 default 20 name 뒤에 추가
alter table test2 add age int default 20 after name;

2. 몇명만 21로 변경(한꺼번에 처리)
update test2 set age = '21' where num in (1,5,7,9,10);

-----------------------------------------------------------------------------------
모든 학생들의 나이를 1살씩 증가
update test2 set age = age+1;
-----------------------------------------------------------------------------------
Day 02
student 테이블 생성
num (1111,2222) pk
name
age
address
major
score

create table student(
num int,
name varchar(20),
age int default 20,
address varchar(50),
major varchar(10),
score int default 0,
primary key(num));

insert 7명
/*INT는 따옴표 X*/
insert into student values
('3333','이유리','20','구리시','불문학과','80'),
('4444','박지원','23','서울시','건축학과','75'),
('5555','이수빈','21','용인시','행정학과','90'),
('6666','김은지','22','인천시','국문학과','60'),
('7777','김가람','20','서울시','영문학과','80');

/*default 값 빼고 입력할경우*/
Insert into student(num,name,address,major)
values
(8888,'김유진','인천시','행정학과'),
(9999,'박길동','용인시','건축학과');

score가 0인 학생의 점수를 update
update student set score = '80' where score=0;
-----------------------------------------------------------------------------------
select - 데이터 조회
//해당 테이블의 모든 데이터 검색
select * from 테이블명;

where 조건;
-컴퓨터학과(computer)만 검색
select * from student where major = 'computer';
-나이가 20보다 많은 학생만 출력
select * from student where age > 20;
-점수가 80점 이상인 학생만 출력
select * from student where score >= 80;
-주소가 서울인 학생의 이름과 주소만 출력
select name,address from student where address = '서울시';
-점수가 70점 미만학생만 별칭으로 바꿔서 출력
select name as '이름', major as '학과', score as '점수' from student where score < 70;
-학교의 학과 목록 출력
 (중복제거(DISTINCT)하고 하나의 데이터만 출력
select distinct major as '학과' from student;
-----------------------------------------------------------------------------------
-비교연산자(>=,>,<=,<,=,<>)
-산술연산자(+ - * /)
-연산을 할 때 값에 null이 포함되어 있다면 계산되지않음
-논리연산(and, or, not)
-우선순위 ()
-----------------------------------------------------------------------------------
-BETWEEN 값 and 값
 값~값 사이를 검색
-in(값1,값2)
 값1 또는 값2를 검색해라
 필드명=값1 or 필드명=값2
-LIKE 값
 값을 포함하고 있는
 LIKE '김%' : 시작이 김인 값
 LIKE '%김' : 끝값이 김인 값
 LIKE '%김%' : 어디든 상관없음
-----------------------------------------------------------------------------------
-major 가 english 인 학생 검색
select * from student where major = 'english';
-major 가 computer 이고 , score 가 70 이상인 학생검색(이름만)
select name as '이름' from student where major = 'computer' and score >=70;
-score 70에서 90사이 학생만 검색
select * from student where score BETWEEN 70 and 90;
-인천과 서울사는 학생만 검색
select * from student where address in('인천시','서울시');
-김철수 학생의 major를 computer 로 변경
update student set major = 'computer' where name = '김철수';
-박지원 학생 삭제
delete from student where name = '박지원';
-김씨 학생 검색
select * from student where name LIKE '김%';
-----------------------------------------------------------------------------------
- score 가 90이상자인 학생의 이름을 성적우수자(필드명)로 출력
select name as '성적우수자' from student where score >=90;
-----------------------------------------------------------------------------------
전체 학생 검색
- 정렬 order by
- 성적 높은 순으로 나열하여 검색
(score) 를 기준으로 내림차순
desc 내림차순 (생략불가)
ASC 오름차순 (생략가능)
select * from student order by score desc;
-나이가 어린 순서대로 출력(성적순)
select * from student order by age, score desc;
-----------------------------------------------------------------------------------
집약과 정렬
집약 : 열의 데이터의 합계, 평균 같은 집계값을 구하기 위한 함수
-count : 검색된 행의 개수
-sum : 합계
-avg : 평균
-max : 최대값
-min : 최소값
-group by : 특정데이터를 기준으로 묶음.
-having : 그룹의 조건
-order by : 정렬
 정렬에 대한 기준은 여러개 줄 수 있음.
 각 필드마다 asc,desc 결정해야함
-limit 시작번지, 개수
 시작번지에서 개수만큼 추출
 --select * from student limit 0,3;
-distinct : 중복제거
-if not EXISTS : 만약 없다면
-if EXISTS : 있다면
 --create table if not exists test1(없다면 만들어줘)
 -----------------------------------------------------------------------------------
기본 명령어 순서
select 검색하고자 하는 필드명
from 테이블명
where 조건
group by 묶을 필드명
having 조건
order by 정렬필드
limit 번지, 개수
-----------------------------------------------------------------------------------
student 테이블에서 검색.
-인원수 검색
--as 생략가능
select count(num) as '학생수' from student;
 
-전체 학생의 점수 합계
select sum(score) '합계' from student;
-각 학과별로 인원수 집계
select major, count(num) '학과별 인원수' from student GROUP by major;
-각 지역별로 인원수 집계
select address, count(num) '지역별 인원수' from student Group by address; 
-학과별 인원수 학과별 합계 집계
select major, count(num) '학과별 인원수', sum(score) '학과별 합계' from student GROUP by major;
-computer 학과의 인원수와 합계
select major '과목', count(num) '학과별 인원수' , sum(score) '학과별 합계' from student Group by major having major = 'computer';
-각 과에서 점수가 가장 높은 사람
select major, MAX(score) from student group by major;
-----------------------------------------------------------------------------------
-if 문 / case when then문 
if(조건식, 참, 거짓)
if(조건식, 참, if(조건문, 참, 거짓))

case
when 조건식 then 값
when 조건식 then 값
when 조건식 then 값
when 조건식 then 값
end;
-----------------------------------------------------------------------------------
-student 테이블에 grade 필드 추가
alter table student add grade int default '1';
grade = 학년을 나타내는 필드
20=1, 21=2, 22=3, 23=4
update student set grade = if(age >22, 4 ,if(age>21, 3 ,if(age>20, 2 , 1)));
update student set grade = 
case
when age=20 then 1
when age=21 then 2
when age=22 then 3
when age>=23 then 4
end;
-----------------------------------------------------------------------------------
4학년 졸업 => 4학년의 값을 졸업생 테이블을 생성하여 이동
=> 원본 테이블의 구조를 복사하여 복사테이블 생성
--create table new_table like table;
create table if not exists sudent_4 like student;
=> 4학년의 데이터를 이동 (복사 후 삭제) 
-- grade 가 4인 학생을 student_4로 복사
   insert into 문 사용 서브쿼리 사용
   서브쿼리란 : 쿼리안에 다른 쿼리문 사용
   insert into student_4
   (select * from student where grade = 4);
-- 삭제
	delete from student where grade=4;
나머지 학생들의 학년을 1학년씩 올려줌
update student set age = age+1 , grade = grade+1;
-----------------------------------------------------------------------------------
장학생명단을 테이블로 생성 => 같은 구조
	create table if not exists student_best like student;
성적이 90점 이상인 학생만 이동
	insert into student_best
	(select * from student where score>=80);
-----------------------------------------------------------------------------------
student 테이블에서 다음 값을 처리
1. 신입생 3명 추가
insert i nto student values
('3333','지동원','20','서울시','computer','60','1'),
('4444','박지원','20','용인시','computer','55','1'),
('6666','이유리','20','인천시','computer','40','1');
2. 등급에(ranking) 칼럼(필드) 추가 A B C
alter table student add ranking varchar(10);
3. score 에 따라서 ranking 값에 A/B/C를 추가
	80점 이상이면 A, 60점 이상이면 B, 나머지는 C
update student set ranking = if(score >=80, 'A' ,if(score >=60, 'B', 'C'));
4. ranking 별 인원수 출력
select ranking , count(num) '랭킹별 인원수' from student GROUP by ranking order by ranking;
5. 1등에서 3등까지만 출력
select * from student order by score desc LIMIT 0,3;
6. 학과의 인원이 3명 미만인 학과를 출력
select major, count(num) from student group by major having count(num)<3;
--select major, count(num) c from student group by major having c <3;
-----------------------------------------------------------------------------------
Day 03

SQL 내장함수
숫자 관련
- 산술연산(+ - * /)
- mod(값, 값2) : 값을 값2로 나눈 나머지
- round(값, 자리수) : 반올림
- ceil(값) : 올림 / floor(값) : 버림 자리수 X
- sqrt(값) : 제곱근 / pow(값,값) : 제곱
- rand() : 0과 1사이의 난수

문자열함수
- concat(str, str) : 문자열 연결
- length(str) : 문자열의 길이(영어1, 한글2)
- char_length(str) : 무조건 한글자로 인식
- substr(str, 시작, 개수) : 문자열에서 시작위치부터 개수만큼 추출(시작이 1)
- left(str, 개수) : 왼쪽에서부터 개수만큼 추출
- right : 오른쪽에서 
- mid(str, 시작, 개수) 
- replace(str, old, new) : str에서 old 값을 찾아 new로 변경
- insert(str, 위치, 길이, 삽입할 문자) : 문자에서 위치의 길이만큼 지우고 삽입
- ucase : 대문자로 / lcase : 소문자로
- space(숫자) : 숫자만큼 공백 추가
- trim(문자) : 문자의 공백 삭제
-- trim(both '-' from '-----abv----'); both 양쪽 / leading 앞에 / tale 뒤에
- lpad(str, 총길이, 채울문자) : 앞쪽에 총길이 만큼(str+공백) 공백을 삽입 후 채울문자를 삽입
- repeat(문자열, 횟수) : 문자열을 횟수만큼 반복
- reverse(문자열) : 문자열을 거꾸로 출력

날짜함수
- adddate / subdate : 날짜를 기준으로 ~후, ~전의 날짜
adddate(날짜, interval 5 day);
interval 뒤쪽 값 : year, month, day, hour, minute, second 가능
- addtime / subtime : 시간을 더하고 뺀 결과
addtime('날짜/시간'.'시:분:초');
- curdate(), curtime(), now(), sysdate() : 오늘날짜/시간
- year(날짜), month, day, hour, minute, second 추출
- date(날짜), time(날짜) 
- datediff(날짜1, 날짜2) : 날짜2에서 날짜1까지 남은 날짜(시간도 가능)
- dayofweek(날짜) : 요일(일요일 = 1, 월요일 =2...)
- monthname(날짜) : 영어로 월이름 리턴
- dayofyear(날짜) : 1년중 몇일이 경과했는지 리턴
- last_day(날짜) : 해당 월의 마지막 일
- time_to_sec(시간) : 시간을 초단위로 변환

정보함수
- user(), current_user(), session_user() : 현재사용자
- database(), schema() : 사용중인 DB명
-----------------------------------------------------------------------------------

student 테이블에서 name을 홍길동 => 홍○동
select num, insert(name, 2, 1, '○') name, age, address, major, score, grade, ranking from student;
-----------------------------------------------------------------------------------
shop database
- mysqluser는 DB를 생성 권한이 없음
  root 유저로 변경하여 실행

create database shop;
권한부여
grant all privileges on shop.* to 'mysqluser'@'localhost';

shop DB
- 제품테이블(product)
- 구매테이블(buy)
create table product(
num int auto_increment,
type_a varchar(50) not null,
type_b varchar(50) not null,
name varchar(100) not null,
price int default 0,
amount int default 100,
sale_amount int default 0,
register_date datetime default now(),
primary key(num));

create table buy(
num int auto_increment,
customer varchar(50),
product_name varchar(100),
price int default 0,
amount int default 0,
buy_date datetime default now(),
primary key(num));

insert into product(type_a, type_b, name, price, amount, sale_amount, register_date) values
('티셔츠','긴소매','폴라 티셔츠',15000,34,100,'2022-10-15'),
('티셔츠','반소매','순면라운드 반팔티',15900,10,153,'2022-09-15'),
('티셔츠','민소매','에이 나시',9000,33,33,'2022-11-10'),
('패션운동복','트레이닝상의','피트니스상의',30000,34,55,'2022-11-05'),
('패션운동복','트레이닝하의','피트니스하의',50000,55,34,'2022-11-06'),
('아우터','재킷','양면 롱 후리스 자켓',23300,100,42,'2022-11-05'),
('아우터','코트','양털 겨울 코트',50000,50,30,'2022-10-31'),
('아우터','패딩','롱 패팅 점퍼',47400,10,45,'2022-11-01');
-----------------------------------------------------------------------------------
홍길동이 폴라 티셔츠 5개를 구매
insert into buy(customer, product_name, price, amount)
values('홍길동','폴라 티셔츠',15000,5);

product 테이블에서 값을 조회하여 추가
홍길순이 폴라 티셔츠 3장 구매
insert into buy(customer, product_name, price, amount)
select '홍길순', name, price, 3 from product where num = 1;

product 테이블과 buy 테이블에서 조회
1. 제품별 판매수량 조회
select product_name , sum(amount) '판매수량' from buy group by product_name;
2. 제품별 판매금액 조회
select product_name, sum(price*amount) '판매금액' from buy group by product_name;
3. type_a 별 제품 종류 조회
select type_a, concat(count(type_a),'종류') '제품종류' from product group by type_a;
4. 전체 총 판매수량과 총매출 조회
select sum(amount) '총 판매수량' , sum(price*amount) '총매출' from product;
-----------------------------------------------------------------------------------
buy 테이블 amount 뒤에 total 필드 추가
price * amount  곱한 값으로 표시
alter table buy add total int after amount;
update buy set total = price*amount;
- 칼럼을 생성시 계산된 값을 자동 계산하여 생성. (generated columns)
- stored : 값이 저장되는 방식(데이터가 입력되거나, 수정될 때 해당 칼럼이 같이 갱신)
- virtual : 데이터를 저장하지 않고 정의만(해당 칼럼을 읽으려고 시도할때 계산을 해서 보여주는 것만)
alter table buy drop total;
alter table buy add total int generated always as (price*amount) stored after amount;

insert into buy(customer, product_name, price, amount)
select '김은지', name, price, 5 from product where num = 1;
-----------------------------------------------------------------------------------
prouduct 테이블에서 조회
1. 최신상품 순으로 정렬(날짜가 가장 늦게 들어온 상품)
select * from product order by register_date desc;
2. type_a 별로 상품개수와 price 합계
select type_a, concat(count(type_a),'종류') '제품종류', sum(price) '가격합계' from product group by type_a;
3. price 16000원 이상인 제품을 할인상품에 해당, 할인 상품만 출력
select * from product where price>=16000;
4. 할인상품의 이름과 가격을 출력 가격 = 할인가격( 16000원 이상인 제품만 대상으로 10% 할인된 가격으로 출력)
   할인상품명, 정상가, 할인가 로 출력
select name '할인상품' , price '정상가', ceil(price*90/100) '할인가격' from product where price>=16000; 
5. 11월에 입고된 상품만 출력
select * from product where monthname(register_date) = 'November';
6. 월별 판매 합계 
select date_format(register_date, '%y-%m') '월' , sum(sale_amount) '판매수량' from product group by 월 order by 월 desc;
7. type_a 별로 판매량(sale_amount) 합계가 가장 큰 품목을 출력
select type_a, sum(sale_amount) '최대판매량' from product group by type_a order by 최대판매량 desc limit 0,1;
--select max(sum) from(select sum(sale_amount) as sum from product group by type_a) as p;
test
--update product set amount = amount+(select sum(amount) from buy where product_name = '폴라 티셔츠');
-----------------------------------------------------------------------------------
Day 04
트랜잭션(TRANSACTION)
- 하나의 작업을 하기위한 명령어 묶음단위
- 하나의 트랜잭션에서 실행하는 모든명령어가 모두완료되어야 전체가 완료되는 형태의 작업에서 사용
- 만약 하나라도 작업이 취소되면 모두 취소
- 완료와 취소를 나중에 결정하는 개념
- 임시 실행 개념
- 데이터의 안전성을 확보하기 위해 사용

start transaction;
명령어1;
명령어2;
...
commit; => 작업완료
rollback; => 전체작업취소

start transaction;
insert into buy(customer, product_name, price, amount)
select '김은지', name, price, 5 from product where num = 1;
insert into buy(customer, product_name, price, amount)
select '이수빈', name, price, 3 from product where num = 7;
commit;
-----------------------------------------------------------------------------------
1. buy테이블에서 customer의 이름을 홍○동 변경하여 출력
select num, insert(customer, 2, 1, '○') customer, product_name, price, amount, total, buy_date from buy;
2. product테이블에서 price가 40000 이상인 데이터만 name+(할인상품)으로 표시하여 출력
select num, type_a, type_b, if(price>=40000, concat(name, '(할인상품)'),name) name, price, amount, sale_amount,register_date from product;
3. 월별 매출(price*sale_amount) 합계 출력
select month(register_date), sum(price*sale_amount) from product group by month(register_date);
4. price가 가장 높은(가장 비싼) 제품명, price 출력
select name, price from product where price = (select max(price) from product);
5. product_non 테이블을 product테이블과 같은 형식으로 추가하여, register_date의 9월 데이터 이동
   -> 복사후 기존 테이블에서 제거
   -> 단)transaction을 이용하여 첫 과정부터 완료되면 commit 하기
start transaction;
create table product_non like product;
insert into product_non
	(select * from product where month(register_date)=9);
delete from product where month(register_date)=9;
commit;
6. 가장 많이 판매한 제품의 이름을 출력 -> buy테이블기준
select product_name , sum(amount) as 'sum' from buy group by product_name order by sum desc limit 0,1;
--select product_name from buy group by product_name having sum(amount) = (select max(total) from (select sum(amount) as total from buy group by product_name) as p);
-----------------------------------------------------------------------------------

create table student(
std_num varchar(10),
std_name varchar(20),
std_major varchar(20),
std_term int,
std_point int,
primary key(std_num));

create table course(
co_code varchar(10),
co_name varchar(20),
co_professor varchar(20),
co_point int,
co_time int,
co_timetable varchar(20),
PRIMARY key(co_code));

create table attend(
at_num int auto_increment,
at_std_num varchar(10),
at_co_num varchar(10),
at_year int,
at_term int,
at_mid int,
at_final int,
at_attend int,
at_hw int,
at_score varchar(4),
at_repetition varchar(1) default 'n',
primary key(at_num));

--외래키를 생성시 추가하는 구문
foreign key(at_std_num) references student(std_num),
foreign key(at_co_num) references course(co_code));

--외래키 추가
alter table attend add foreign key(at_std_num) references student(std_num);
alter table attend add foreign key(at_co_num) references course(co_code);
insert into student values
('2019160123','전봉준','컴퓨터공학과',2,64),
('2019456001','강길동','디자인',3,60),
('2020123001','강나래','화학공학',1,21),
('2020123020','박철수','화학공학',1,20),
('2020160001','강철수','컴퓨터공학',1,20),
('2020160002','나영희','컴퓨터공학',1,19);

insert into course values
('2020ipc001','컴퓨터개론','유관순',2,2,'화1A,1B,2A,2B'),
('2020ipc002','기초전기','이순신',3,4,'월1A,1B,2A목1A,1B,2A'),
('2020msc001','대학수학기초','홍길동',3,3,'월1A,1B,2A수1A,1B,2A'),
('2020msc002','프로그래밍일반','임꺽정',3,3,'월1A,1B,2A목1A,1B,2A');

insert into attend(at_std_num, at_co_num) values
('2020160001','2020msc001'),
('2020160002','2020msc001'),
('2019160123','2020msc002'),
('2019456001','2020msc002'),
('2020123001','2020ipc001'),
('2020123020','2020ipc001'),
('2019456001','2020ipc002'),
('2019160123','2020ipc002'),
('2020160001','2020msc002'),
('2020160002','2020msc002'),
('2019160123','2020msc001'),
('2019456001','2020msc001'),
('2020123001','2020msc001'),
('2020123020','2020msc001'),
('2019456001','2020msc002'),
('2019160123','2020msc002');


1. at_year 를 2023년으로 업데이트
update attend set at_year = 2023;
2. at_term at_num 1~8 => 1, 9~=> 2 업데이트
update attend set at_term = if(at_num<=8, 1, 2);
3. 1학기만 at_mid / at_final / at_attend / at_hw 점수채우기
40/ 40/ 10/ 10 => 총 100점
update attend set at_mid = 20, at_final = 30, at_attend = 5, at_hw = 5 where at_num = 8;
4. at_score 는 mid+final+attend+hw 90이상 A /80 이상 B /70 이상 C /60 이상 D/F
update attend set at_score = (
if((at_mid+at_final+at_attend+at_hw)>=90,'A', 
if((at_mid+at_final+at_attend+at_hw)>=80,'B',
if((at_mid+at_final+at_attend+at_hw)>=70,'C',
if((at_mid+at_final+at_attend+at_hw)>=60,'D','F')))));

alter table attend add total int generated always as (at_mid+at_final+at_attend+at_hw) virtual;
update attend set at_score = 
if(total>=90, 'A', if(total>=80, 'B', if(total>=70, 'C', if(total>=60, 'D', 'F'))));

- 2학기 score null로 변경
update attend set at_score = null where at_term = 2;
update attend set at_repetition = null where at_term = 2;
- at_repetition 재수강여부 1학기만 채우기
at_score F 이거나, at_attend가 3미만이면 y 아니면 n
update attend set at_repetition = (
if(at_score = 'F', 'y', if(at_attend<3, 'y', 'n'))) where at_term = 1;

- 재수강 인원 집계
select at_repetition, count(at_repetition) '재수강인원' from attend where at_repetition = 'y';
- score별 인원수 집계
--null 인지 확인 => is null /null 아닌지 확인 is not null
select at_score '학점', count(at_score) '인원' from attend group by at_score having at_score is not null order by at_score;
-----------------------------------------------------------------------------------
Day 05
join (조인) 테이블 연결
- inner join (내부조인) : 일반적인 조인
  - 두 테이블을 조인할 때 사용
  - 두 테이블 모두 지정한 열의 데이터가 있어야 함
- outer join (외부조인) 
  - 두 테이블 조인할 때 사용
  - 두 테이블 중 1개의 테이블에만 데이터가 있어도 결과 도출
- cross join (상호조인)
  - 두 테이블의 모든 행을 조인하는 기능
- self join  (자체조인)
  - 자기자신의 테이블과 조인한다는 의미
  - 1개의 테이블로 조인할 때 사용
-----------------------------------------------------------------------------------
- 재수강자 명단 추출
select s.std_name, a.at_repetition from student s
inner join attend a
on s.std_num = a.at_std_num
where a.at_repetition = 'y';

select * from student s
inner join attend a
on s.std_num = a.at_std_num;

-  at_score 가 A인 학생명단을 출력
(학번, 이름, 학점)
select s.std_num, s.std_name, a.at_score from student s
inner join attend a
on s.std_num = a.at_std_num
where a.at_score = 'A';
-----------------------------------------------------------------------------------
1. F 를 받은 학생명단 (학번, 이름, 학과)
select a.at_score, s.std_num, s.std_name, s.std_major from student s
inner join attend a
on s.std_num = a.at_std_num
where a.at_score = 'F';
2. A 학점을 받은 학생 (학번, 이름 , 과목)
select a.at_score, s.std_num, s.std_name, c.co_name from student s
inner join attend a
on s.std_num = a.at_std_num
inner join course c
on a.at_co_num = c.co_code
where a.at_score = 'A';
3. A 를 받은 학생명단 (학번, 이름, 과목, 성적) (at_mid+at_final+at_attend+at_hw) as '성적'
select a.at_score, s.std_num, s.std_name, c.co_name, (a.at_mid+a.at_final+a.at_attend+a.at_hw) as '성적' 
from student s
inner join attend a
on s.std_num = a.at_std_num
inner join course c
on a.at_co_num = c.co_code
where a.at_score = 'A';
4. 과목별로 중간, 기말, 출석, 과제의 합계
- 과목별 오름차순
프로그래밍일반 35 35 10 10
프로그래밍일반 35 35 10 10
			 70 70 20 20
select c.co_name, sum(a.at_mid), sum(a.at_final), sum(a.at_attend), sum(a.at_hw) from attend a 
inner join course c
on a.at_co_num = c.co_code
group by c.co_name order by c.co_name;
5. 학점별 중간, 기말, 출석, 과제 (각각의) 평균
- null 제외, 학점별 오름차순
select at_score, ceil(avg(at_mid)), ceil(avg(at_final)), ceil(avg(at_attend)), ceil(avg(at_hw))
from attend group by at_score having at_score is not null order by at_score;
6. 강철수가 수강하고 있는 과목들의 (이름, 교수명)
select s.std_name, c.co_name, c.co_professor
from student s
inner join attend a
on s.std_num = a.at_std_num
inner join course c
on a.at_co_num = c.co_code
where s.std_name = '강철수';
-----------------------------------------------------------------------------------
rollup : 그룹함수로 집계된 데이터의 합계/소계 
1. group by rollup(그룹칼럼)
2. group by 칼럼명 with rollup
- 그룹함수 종류에 따라 집계
select if(c.co_name is null,'합계',co_name) '과목' , sum(a.at_mid), sum(a.at_final), sum(a.at_attend), sum(a.at_hw) from attend a 
inner join course c
on a.at_co_num = c.co_code
group by c.co_name with rollup order by grouping(c.co_name);

select if(at_score is null, '평균', at_score) as at_score,
avg(at_mid), avg(at_final), avg(at_attend), avg(at_hw)
from attend where at_score is not null 
group by at_score with rollup order by grouping(at_score);
-----------------------------------------------------------------------------------
1. 학번이 2020으로 시작하는 학생들의 학번,이름,학과를 출력
select std_num, std_name, std_major from student where std_num like '2020%';
2. 프로그래밍일반 과목을 듣는 학생 명단출력 (학번,이름,학과)
select s.std_num, s.std_name, s.std_major, a.at_term
from student s
inner join attend a
on s.std_num = a.at_std_num
inner join course c
on a.at_co_num = c.co_code
where c.co_name = '프로그래밍일반';
3. 홍길동 교수가 강의하는 과목을 듣는 학생 명단 출력 (학번, 이름, 학과, 수강과목, 담당교수)
select s.std_num, s.std_name, s.std_major, c.co_name, c.co_professor from student s
inner join attend a
on s.std_num = a.at_std_num
inner join course c
on a.at_co_num = c.co_code
where c.co_professor = '홍길동';
4. 전봉준이 획득한 학점(co_point)의 합계 => 2학기는 미포함, 미이수학점도 미포함
select s.std_name, sum(c.co_point) as '학점' from student s
inner join attend a
on s.std_num = a.at_std_num
inner join course c
on a.at_co_num = c.co_code
where a.at_term = 1 and a.at_repetition = 'n'
group by s.std_name
having s.std_name = '전봉준';
-----------------------------------------------------------------------------------
student 테이블에 신입생 추가 3명
insert into student values
('2023222001','이유리','디자인',1,20),
('2023222002','박지원','컴퓨터공학',1,20),
('2023222003','이수빈','디자인',1,20);

신입생은 수강신청을 하지 않은 상태
student 에는 존재하나, attend 에는 존재하지 않는 학번이 있음
- 조인 후 수강하고 있지 않는 명단 출력
(inner) join : 두테이블에 일치하는 데이터만 출력
left (outer) join : 왼쪽테이블을 기준으로 모든 대상 조인
select s.* from student s 
left outer join attend a
on std_num=at_std_num
where at_num is null;
-----------------------------------------------------------------------------------
Day 06
college DB생성 권한부여
create database college;
grant all privileges on college.* to 'mysqluser'@'localhost' with grant option;
flush privileges;

기본테이블 생성
create table student(
st_num int auto_increment,
st_name varchar(20) not null,
st_term int default 0,
st_point int default 0,
primary key(st_num));

create table subject(
su_num int auto_increment,
su_code varchar(20),
su_title varchar(45),
su_point int default 0,
su_time int default 0,
primary key(su_num));

create table professor(
pr_num int auto_increment,
pr_name varchar(20) not null,
pr_age int not null,
pr_room varchar(20),
pr_state varchar(20) default '재직',
pr_position varchar(20) default '조교수',
primary key(pr_num));

관계테이블 생성
create table attend(
at_num int auto_increment,
at_std_num int not null,
at_co_num int not null,
at_mid int default 0,
at_final int default 0,
at_attend int default 0,
at_hw int default 0,
at_score varchar(5),
at_pass varchar(5) default 'f',
at_repetition varchar(5) default 'n',
primary key(at_num));

create table course(
co_num int auto_increment,
co_pr_num int,
co_su_num int,
co_term int default 1,
co_year int,
co_timetable varchar(100),
primary key(co_num));

create table guide(
gu_num int auto_increment,
gu_pr_num int,
gu_st_num int,
gu_year int,
primary key(gu_num));

외래키추가
alter table attend add foreign key(at_std_num) references student(st_num);
alter table guide add foreign key(gu_st_num) references student(st_num);
alter table course add foreign key(co_su_num) references subject(su_num);
alter table course add foreign key(co_pr_num) references professor(pr_num);
alter table guide add foreign key(gu_pr_num) references professor(pr_num);
alter table attend add foreign key(at_co_num) references course(co_num);

데이터입력
insert into student(st_num, st_name,st_term) values
(2020123001,'김영철',2),
(2020123002,'나영희',2),
(2020160001,'강철수',2),
(2020160002,'박철수',2),
(2020456001,'강군',2);

insert into subject values
(1,'msc001','대학수학',3,3),
(2,'com001','컴퓨터개론',2,2),
(3,'com002','운영체제',3,3),
(4,'abc001','글쓰기',2,2),
(5,'abc002','영어',2,3);

insert into professor values
(2005789001, '홍길동',60,'B동302호','재직','정교수'),
(2006456001, '박영실',60,'B동301호','안식년','정교수'),
(2010160001, '강길동',55,'A동202호','재직','조교수'),
(2011123001, '이순신',55,'A동203호','재직','조교수');


insert into course(co_pr_num, co_su_num, co_term, co_year, co_timetable) values
(2005789001,1,1,2002,'월2a/2b/3a/3b/4a/4b'),
(2005789001,1,2,2002,'월2a/2b/3a/3b/4a/4b'),
(2010160001,2,1,2002,'화1a/1b/2a/2b'),
(2010160001,3,1,2002,'목2a/2b/3a/3b/4a/4b'),
(2011123001,4,2,2002,'화1a/1b/2a/2b'),
(2011123001,5,2,2002,'수1a/1b/2a/2b');

insert into guide(gu_pr_num, gu_st_num, gu_year) values
(2010160001,2020160001,2020),
(2010160001,2020160002,2020),
(2011123001,2020123001,2020),
(2011123001,2020123002,2020),
(2006456001,2020456001,2020);

insert into attend(at_st_num, at_co_num) values
(2020123001,1),
(2020123001,2),
(2020123001,3),
(2020123001,4),
(2020123001,5),
(2020123001,6),
(2020123002,1),
(2020123002,2),
(2020123002,3),
(2020123002,4),
(2020160001,1),
(2020160001,2),
(2020160001,3),
(2020160001,4),
(2020160001,5),
(2020160001,6),
(2020160002,1),
(2020160002,2),
(2020160002,3),
(2020160002,4),
(2020160002,5),
(2020160002,6),
(2020456001,1),
(2020456001,2),
(2020456001,3),
(2020456001,4),
(2020456001,5);
-----------------------------------------------------------------------------------
1. 김영철이 수강하는 과목명 출력
select s.st_name, su.su_title from student s
inner join attend a
on s.st_num = a.at_st_num
inner join course c
on a.at_co_num = c.co_num
inner join subject su
on c.co_su_num = su.su_num
where s.st_name = '김영철';
--서브쿼리 구문
select s.st_name, 
		(select su_title from subject 
			where su_num = co_su_num
		) as su_title
from student s
	inner join attend a on s.st_num = a.at_st_num
	inner join course c on a.at_co_num = c.co_num
where 
	s.st_name = '김영철';

2. 강길동 교수가 지도하는 학생명 출력
select s.st_name as '강길동교수 지도학생' from student s
inner join guide g
on s.st_num = g.gu_st_num
inner join professor p
on g.gu_pr_num = p.pr_num
where p.pr_name = '강길동';
--서브쿼리 구문
select
	(
		select st_name from student
		where st_num = gu_st_num
	) as '강길동교수 지도학생'
from guide
	join professor on pr_num = gu_pr_num
where 
	pr_name = '강길동';
3. 대학수학 과목을 수강하는 수강자명단을 출력
select distinct s.st_name as '대학수학 수강자' from student s
inner join attend a
on s.st_num = a.at_st_num
inner join course c
on a.at_co_num = c.co_num
inner join subject su
on c.co_su_num = su.su_num
where su.su_title = '대학수학';
--서브쿼리 구문
select distinct
	(
		select st_name from student s
		where st_num = at_st_num
	) as '대학수학 수강자'
from attend a
	join course c on co_num = at_co_num
	join subject su on su_num = co_su_num
where 
	su_title = '대학수학';
-----------------------------------------------------------------------------------
1. at_mid , at_final , at_attend , at_hw 값 업데이트
40, 40, 10, 10
update attend set
at_mid=ceil(rand()*39),
at_final=ceil(rand()*39), 
at_attend=ceil(rand()*9), 
at_hw=ceil(rand()*9);
2. 합계 값을 이용하여 at_score 업데이트
90 A / 80 B / 70 C / 60 D / F
update attend set at_score = (
if((at_mid+at_final+at_attend+at_hw)>=90,'A', 
if((at_mid+at_final+at_attend+at_hw)>=80,'B',
if((at_mid+at_final+at_attend+at_hw)>=70,'C',
if((at_mid+at_final+at_attend+at_hw)>=60,'D','F')))));
3. at_pass 값 업데이트 (p/f) 
at_score가 A 또는 B 이면 p(pass) 아니면 f(fail)
update attend set at_pass = if(at_score = 'A' or at_score = 'B', 'p', 'f');
4. at_repetition 값 업데이트
at_score 가 F이거나, at_attend 가 3이하인 사람은 y 아니면 n
update attend set at_repetition = if(at_score = 'F' , 'y', if(at_attend<=3, 'y', 'n'));
-----------------------------------------------------------------------------------
rank() => mysql 8.0 이전 버전에는 없음.
8.0 이후 버전에서만 사용가능.
60 4 3
70 3 2
80 1 1
80 1 1
rank() over() : 동일한 값이 존재해도 순위가 같음
order by 를 이용하여 정렬한 후 순위 매김
dense_rank() over() : 동일한 값이 존재하면 순위가 같음

순위가 1,2,3 등인 학생만 출력
select *, rank() over(order by score desc) as rank_score from student where rank_score <=3;
=> 오류 rank_score 칼럼이 원래 없는 칼럼이기 때문
select * from (
			select *, rank() over(order by score desc) as rank_score from student
			)as s
where
	s.rank_score<=3;
-----------------------------------------------------------------------------------
1. attend 테이블에 검색
전체 합계를 기준으로 내림차순하여 순위
select *, rank() over(order by at_mid+at_final+at_attend+at_hw desc) as rank_score from attend;
2. 구한 순위에서 1~5등 까지만 출력
select * from (
	select *, rank() over(order by at_mid+at_final+at_attend+at_hw desc) as rank_score from attend
)as s
where s.rank_score <=5;
3. 이름, 순위
select s.st_name, s.rank_score from (
	select *, rank() over(order by at_mid+at_final+at_attend+at_hw desc) as rank_score from attend
)as s
join student s
on s.st_num = at_st_num
where s.rank_score <=5
order by s.rank_score;

4. 이름, 과목, 순위
select s.st_name,su.su_title, s.rank_score from (
	select *, rank() over(order by at_mid+at_final+at_attend+at_hw desc) as rank_score from attend
)as s
join student s
on s.st_num = at_st_num
join course c
on c.co_num = at_co_num
join subject su
on su.su_num = c.co_su_num
where s.rank_score <=5
order by s.rank_score;
-----------------------------------------------------------------------------------
Day 07
index 인덱스 (키)
- 테이블에 조회 속도를 높여주는 자료구조
- 조회 속도는 빨라지지만 update, insert, delete 속도가 저하되는 단점이 있음.
- 인덱스 MYSQL INDEX 파일에 저장
- 인덱스는 하나 또는 여러 개 칼럼에 설정이 가능
- 여러 칼럼을 묶어 하나의 인덱스로 설정도 가능
- 인덱스는 where 절 뒤에서 사용할 때만 성능에 영향을 끼침
- order by, group by에 대한 index도 성능에 영향을 미침
-----------------------------------------------------------------------------------
student 테이블에 st_name에 인덱스 추가
- create index idx_name on student(st_name);	--추가
- alter table student add index (st_name);		--추가
- alter table student drop index idx_name;		--삭제
- show index from 테이블명; 						--인덱스 보기

-----------------------------------------------------------------------------------
- 테이블 생성시 인덱스 추가
create table 테이블명(
id int,
name varchar(10),
address varchar(45),
primary key(id),
key idx_name(name));
key 인덱스명(칼럼)
-----------------------------------------------------------------------------------
view 생성
- 데이터베이스에 존재하는 가상테이블
- 자주 조회하는 값을 별도로 저장하는 기능
- 실제 테이블을 만드는 것이 아닌 논리적으로만 존재
- 여러 테이블에 존재하는 각각의 칼럼을 보여줘야 할 때
- 보여주기만 가능(insert, update, delete 불가능)
- 뷰는 index를 가질 수 없다
뷰 생성 구문
- 단일 뷰
create view view_name as
select 칼럼명 from 테이블명
where 조건;


- 복합 뷰(여러개의 테이블)
join 가능
그룹함수 가능
distinct 가능
create view view_name as
select a.칼럼, b.칼럼
from table_a a,table_b b
where 조건;

- 뷰는 생성/삭제만 가능 변경불가능
- 뷰는 한번 생성하면 변경이 불가능하므로, 새로만든 뷰로 대체할 수 있음.
- replace => create 대신 사용
- create or replace view_name as select 칼럼 from 테이블;

뷰조회
 select * from view_name;
뷰삭제
 drop view view_name;
-----------------------------------------------------------------------------------
attend 테이블에서 at_score 가 A 인 학생의 뷰
create view A_score as
select at_st_num,at_co_num, at_score from attend
where at_score = 'A'; 

select * from A_score;

show tables; (veiw도 테이블처럼 표시)
show full tables; (테이블 상세보기)
-----------------------------------------------------------------------------------
1학기 수업을 듣는 학생을 검색
학번, 이름 조건 : 1학기 수강자


create or replace view 1_term as
select s.st_num, s.st_name, c.co_term
from student s,course c
where c.co_term = 1;

--join 포함
create or replace view 1_term as
select s.st_num, s.st_name, c.co_term
from student s
join attend a on a.at_st_num = s.st_num
join course c on c.co_num = a.at_co_num
where c.co_term = 1;

school DB 에서 view 생성
1. 컴퓨터 공학과 뷰 생성 (com_view)
학번, 이름, 학과
create view com_view as
select s.std_num, s.std_name, s.std_major
from student s
where s.std_major = '컴퓨터공학';
2. A학점인 학생 뷰 생성(Ascore_view)
학번, 이름, 학점
create view Ascore_view as
select s.std_num, s.std_name, a.at_score
from student s
join attend a on s.std_num = a.at_std_num
where a.at_score = 'A';
-----------------------------------------------------------------------------------
trigger 트리거 : 연쇄반응(작용)
- 트리거 : 이벤트에 반응하여 자동으로 실행되는 구문
- 이벤트가 발생했을 때 데이터의 무결성(일관성)을 지켜야 할 때 사용
- 한 번 생성하면 중복생성X, 수정X
- 삭제 후 재생성 : if exists / if not exists
- 이벤트 : update / insert / delete
트리거 
구문의 끝 => ;
트리거 구문(
sql 구문;
sql 구문;
);
- 끝 구문의 처리기호를 변경
- delimiter : sql구문의 끝을 다른 기호로 표시할 때 사용

delimiter 기호 ($$ //) 
- 반드시 띄어쓰기 필수
-----------------------------------------------------------------------------------
트리거 생성 구문
drop trigger if exists trigger_name
delimiter //
create trigger trigger_name (after | before) event on table_name
for each row
begin
[실행구문;]
end //
delimiter ; 
트리거 삭제 구문
drop trigger if exists trigger_name
-----------------------------------------------------------------------------------
변수 선언 가능
SET @변수명 = 값;  (같다기호 ==)
SET @변수명 := 값; (대입기호 = )
SELECT @변수명 := 값;
mysql = (같다)
SET 이외의 명령어에서는 = (비교연산자)로 취급
-- 일반 SQL 구문에서 사용가능 전역변수 (사용자지정 변수, 전역변수)
SET @start=1, @end =5;
SET @start:=1, @end :=5;
SELECT @start :=1, @end :=5;
select * from attend where at_score BETWEEN @start and @end;
-- 지역변수 (일정 영역안에서만 사용)
DECLARE 변수선언
SET : 변수에 값 할당
DECLARE _amount int default 0
set _amount = amount; 

new : 이벤트가 발생하여 새롭게 생긴 데이터
old : 이벤트가 발생하기 전에 있던 데이터
insert : 추가 => new 데이터 발생
delete : 삭제 => old 데이터 발생
update : 수정 => 수정전의 데이터 old /수정후의 데이터 new
-----------------------------------------------------------------------------------
- buy 테이블에 데이터가 추가되면 product 테이블에 amount - / sale_amount +
홍길동 폴라 티셔츠 5개 구매
drop trigger if exists insert_buy;
delimiter //
create trigger insert_buy after insert on buy
for each row
begin

DECLARE _amount int default 0;
SET _amount = new.amount;

update product set
amount = amount - _amount, sale_amount = sale_amount + _amount
where name = new.product_name;

end //
delimiter ;
--트리거 생성시 오류날 때 (root 계정에서)
set global log_bin_trust_function_creators=on
데이터 입력
insert into buy(customer, product_name, price, amount) values('홍길동','폴라 티셔츠',15000,5);
insert into buy(customer, product_name, price, amount) values('김영이','에이 나시',9000,20);
-----------------------------------------------------------------------------------
buy 테이블에 데이터를 삭제하면 amount / sale_amount 변경
delimiter //
create trigger delete_buy before delete on buy
for each row
begin

DECLARE _amount int default 0;
SET _amount = old.amount;

update product set
amount = amount + _amount, sale_amount = sale_amount - _amount
where name = old.product_name;

end //
delimiter ;
-----------------------------------------------------------------------------------
buy 테이블의 데이터를 업데이트 하면 amount 값과 sale_amount 값을 변경
drop trigger if exists update_buy;
delimiter //
create trigger update_buy after update on buy
for each row
begin

update product set
amount = amount + old.amount,
sale_amount = sale_amount - old.amount,
amount = amount - new.amount,
sale_amount = sale_amount + new.amount
where name = new.product_name;

end //
delimiter ;
-----------------------------------------------------------------------------------
school DB에서 처리
1. course 테이블에 해당 코스의 수강인원을 집계하는 필드를 생성
필드명 : co_degree
alter table course add co_degree int after co_timetable;
2. co_degree 필드에 해당 코드를 수강하고 있는 학생의 인원수를 집계하여 업데이트
update course set co_degree = (select count(at_co_num) from attend gro up by at_co_num having co_code = at_co_num);
3. attend에 수강신청을 하면 course의 co_degree가 자동으로 증가하는 트리거 생성
drop trigger if exists insert_attend;
delimiter //
create trigger insert_attend after insert on attend
for each row
begin
update course set
co_degree = co_degree+1
where co_code = new.at_co_num;
end //
delimiter ;


insert into attend(at_std_num, at_co_num, at_year) values('2020123020', '2020ipc002' , '2023');
-----------------------------------------------------------------------------------
Day 08
update 트리거 생성
attend 테이블에 값이 변경되면 (at_co_num)
co_degree의 값도 같이 변경되도록 트리거 작성
drop trigger if exists update_attend;
delimiter //
create trigger update_attend after update on attend
for each row
begin
update course set
co_degree = co_degree+1
where co_code = new.at_co_num;
update course set
co_degree = co_degree-1
where co_code = old.at_co_num;
end //
delimiter ;

update attend set at_co_num = '2020ipc001' where at_num = 22;
-----------------------------------------------------------------------------------
- 스토어드 프로시저(procedure)
function method 같은 역할을 하는 DB구문
프로시저는 일련의 쿼리를 모아 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합이다.

- 프로시저 목록 확인
show procedure status;
- 프로시저 호출
call procedure_name;
- 프로시저 내용 조회
show create procedure 프로시저명;

delimiter //
create procedure 프로시저명(in 매개변수, out 리턴타입)
--프로시저 내용 정의
--변수 사용 가능
-- declare : 지역변수 선언
-- set : 변수값 설정
begin
..
end //
delimiter ;
-----------------------------------------------------------------------------------
shop DB에서 처리
제품명을 입력하면 그 제품을 구매한 customer를 반환
'폴라 티셔츠'라는 제품을 입력하면 그 제품을 구매한 손님 리스트를 반환
프로시저명 : select_buy
매개변수 : 제품명(IN in_product_name)

drop procedure if exists select_buy;
delimiter //
create procedure select_buy (in in_product_name varchar(100))
begin
select customer from buy where product_name = in_product_name;
end //
delimiter ;
procedure 호출
call select_buy('폴라 티셔츠');

buy 테이블에 insert 하기
insert into buy(customer, product_name, price, amount)
values
('김철수', '양면 롱 후리스 자켓', 23300 , 7),
('이유리', '양털 겨울 코트', 50000 , 13), 
('이수빈', '순면라운드 반팔티', 15900 , 30), 
('김은지', '폴라 티셔츠', 15000 , 10), 
('유관순', '롱 패팅 점퍼', 47400 , 17); 
-----------------------------------------------------------------------------------
구매 금액의 합이 50만원 이상인 손님이름과 구매 가격을 출력하는 프로시저 작성
매개변수 받아서
drop procedure if exists select_total;
delimiter //
create procedure select_total(in in_total int)
begin
select customer, sum(total) from buy group by customer having sum(total)>=in_total;
end //
delimiter ;
50만원 이상
drop procedure if exists select_50;
delimiter //
create procedure select_50()
begin
select customer,sum(total) from buy group by customer having sum(total)>=500000;
end //
delimiter ;
-----------------------------------------------------------------------------------
특정 제품을 구매한 인원수를 리턴하는 프로시저를 작성
프로시저명 : count_buy
매개변수 : in 제품명
리턴 : out 개수
drop procedure if exists count_buy;
delimiter //
create procedure count_buy(IN in_product_name varchar(100) ,OUT out_count int)
begin
select count(product_name) into out_count from buy where product_name = in_product_name;
end //
delimiter ;

호출
call count_buy('에이 나시', @count);
출력
select @count as '판매수량';
-----------------------------------------------------------------------------------
drop procedure if exists count_amount;
delimiter //
create procedure count_amount(IN in_product_name varchar(100) ,OUT out_count int)
begin
select sum(amount) into out_count from buy group by product_name having product_name = in_product_name;
end //
delimiter ;
-----------------------------------------------------------------------------------
과제
college DB 사용
student 테이블의 st_point(이수학점) 를 update 하는 프로시저 작성
학점을 주는 조건 : at_repetition = 'n'이면 학점을 획득 'y'면 안줌
학점은 attend 테이블의 at_co_num 가 어느 과목인지 확인
subject 테이블에서 학점(su_point) 확인 후
student 테이블에 su_point를 업데이트
- 프로시저 작성
call update_stpoint(학번); //학번에 해당하는 st_point 만 업데이트
call update_stpointAll(); //전체 한꺼번에 변경

drop procedure if exists update_stpoint;
delimiter //
create procedure update_stpoint(IN in_st_num int)
begin
update student set st_point = (select sum(su_point) from subject
join course c
on co_su_num = su_num
join attend a
on co_num = at_co_num
where at_repetition = 'n' and at_st_num = in_st_num
group by at_st_num)
where st_num = in_st_num;
end //
delimiter ;

call update_stpoint(2020123001);

drop procedure if exists update_stpointAll;
delimiter //
create procedure update_stpointAll()
begin
update student set st_point = (select sum(su_point) from subject
join course c
on co_su_num = su_num
join attend a
on co_num = at_co_num
where at_repetition = 'n' and st_num = at_st_num
group by at_st_num);
end //
delimiter ;

call update_stpointAll();